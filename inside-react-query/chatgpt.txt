√öltimamente me han preguntado mucho c√≥mo funciona React Query internamente. ¬øC√≥mo sabe cu√°ndo volver a renderizar? ¬øC√≥mo elimina duplicados? ¬øC√≥mo es que es independiente del framework?

Estas son todas muy buenas preguntas, as√≠ que echemos un vistazo detr√°s de escena de nuestra querida biblioteca de gesti√≥n de estado as√≠ncrono y analicemos qu√© sucede realmente cuando llamas a `useQuery`.

Para comprender la arquitectura, debemos comenzar desde el principio:

El QueryClient

[img]
[alt]El QueryClient con sus opciones predeterminadas contiene la QueryCache.

Todo comienza con un QueryClient. Esa es la clase de la cual creas una instancia, probablemente al comienzo de tu aplicaci√≥n, y luego la haces accesible en todas partes a trav√©s del QueryClientProvider:

---Code Snippet---
query-client-provider
Copyquery-client-provider: copy code to clipboard
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

// ‚¨áÔ∏è this creates the client
const queryClient = new QueryClient()

function App() {
  return (
    // ‚¨áÔ∏è this distributes the client
    <QueryClientProvider client={queryClient}>
      <RestOfYourApp />
    </QueryClientProvider>
  )
}
---Code Snippet---

El QueryClientProvider utiliza el contexto de React para distribuir el QueryClient en toda la aplicaci√≥n. El cliente en s√≠ es un valor estable: se crea una vez (aseg√∫rate de no recrearlo inadvertidamente con demasiada frecuencia), por lo que este es un caso perfecto para utilizar Contexto. No har√° que tu aplicaci√≥n se vuelva a renderizar, simplemente te brinda acceso a este cliente a trav√©s de useQueryClient.

Una entidad que contiene la cach√©
Puede que no sea muy conocido, pero el QueryClient en s√≠ no hace mucho. Es un contenedor para la QueryCache y la MutationCache, las cuales se crean autom√°ticamente cuando creas un nuevo QueryClient.

Tambi√©n contiene algunos valores predeterminados que puedes establecer para todas tus consultas y mutaciones, y proporciona m√©todos convenientes para trabajar con las cach√©s. En la mayor√≠a de las situaciones, no interactuar√°s directamente con la cach√©, sino que acceder√°s a ella a trav√©s del QueryClient.

Consulta en cach√©
Muy bien, entonces el cliente nos permite trabajar con la cach√©, ¬øqu√© es la cach√©?

[img]
[alt]QueryCache consiste en consultas y se sincroniza con Persisters.

En pocas palabras, QueryCache es un objeto en memoria donde las claves son una versi√≥n serializada de manera estable de tus queryKeys (llamado queryKeyHash) y los valores son una instancia de la clase Query.

Es importante entender que React Query, por defecto, solo almacena datos en memoria y en ning√∫n otro lugar. Si recargas la p√°gina del navegador, la cach√© desaparecer√°. Si deseas escribir la cach√© en un almacenamiento externo como localstorage, debes consultar los persisters.

Consulta

[img]
[alt]La consulta informa al Observador

La cach√© tiene consultas, y una consulta (Query) es donde ocurre la mayor parte de la l√≥gica. No solo contiene toda la informaci√≥n sobre una consulta (sus datos, campo de estado o informaci√≥n meta como cu√°ndo ocurri√≥ la √∫ltima recuperaci√≥n), sino que tambi√©n ejecuta la funci√≥n de la consulta y contiene la l√≥gica de reintentos, cancelaci√≥n y deduplicaci√≥n.

Tiene una m√°quina de estados interna para asegurarse de que no nos encontremos en estados imposibles. Por ejemplo, si se debe activar una funci√≥n de consulta mientras ya estamos recuperando datos, esa recuperaci√≥n puede ser deduplicada. Si se cancela una consulta, vuelve a su estado anterior.

Lo m√°s importante es que la consulta sabe qui√©n est√° interesado en los datos de la consulta, y puede informar a esos observadores sobre todos los cambios.

Observador de la consulta

[img]
[alt]El observador es creado por useQuery e informa al componente sobre las actualizaciones

Los Observadores son el enlace entre la Consulta (Query) y los componentes que desean utilizarla. Se crea un Observador cuando llamas a useQuery, y siempre est√° suscrito a una sola consulta. Por eso debes pasar un queryKey a useQuery. üòâ

Sin embargo, el Observador hace un poco m√°s: es donde ocurre la mayor√≠a de las optimizaciones. El Observador sabe qu√© propiedades de la Consulta est√° utilizando un componente, por lo que no tiene que notificarle cambios no relacionados. Por ejemplo, si solo utilizas el campo de datos (data), el componente no tiene que volver a renderizarse si isFetching est√° cambiando durante una nueva recuperaci√≥n en segundo plano.

Adem√°s, cada Observador puede tener una opci√≥n de selecci√≥n (select), donde puedes decidir qu√© partes del campo de datos (data) te interesan. Ya he hablado antes sobre esta optimizaci√≥n en el art√≠culo n.¬∫ 2: Transformaciones de datos en React Query. La mayor√≠a de los temporizadores, como los de staleTime o intervalos de recuperaci√≥n, tambi√©n ocurren a nivel de observador.

Consultas activas e inactivas
Una consulta (Query) sin un Observador se denomina consulta inactiva. Todav√≠a est√° en la cach√©, pero no est√° siendo utilizada por ning√∫n componente. Si echas un vistazo a las React Query Devtools, ver√°s que las consultas inactivas est√°n atenuadas. El n√∫mero en el lado izquierdo indica la cantidad de Observadores que est√°n suscritos a la consulta.

[img]
[alt]Devtols donde una consulta tiene dos observadores y otra no tiene ninguno

La imagen completa

[img]
[alt]Vista completa de la arquitectura

Poni√©ndolo todo junto, podemos ver que la mayor parte de la l√≥gica se encuentra dentro del n√∫cleo de la Consulta (Query Core), independiente del framework: QueryClient, QueryCache, Query y QueryObserver est√°n todos all√≠.

Por eso es bastante sencillo crear un adaptador para un nuevo framework. B√°sicamente, necesitas una forma de crear un Observador, suscribirte a √©l y volver a renderizar tu componente si se notifica al Observador. Los adaptadores useQuery para React y Solid tienen alrededor de solo 100 l√≠neas de c√≥digo.

Desde la perspectiva de un componente
Por √∫ltimo, veamos el flujo desde otro √°ngulo, comenzando con un componente:

[img]
[alt]Flujo desde el montaje del componente, pasando por la obtenci√≥n de datos, hasta su renderizado.

- El componente se monta, llama a useQuery, que crea un Observador.
- Ese Observador se suscribe a la Consulta, que se encuentra en la QueryCache.
- Esa suscripci√≥n puede desencadenar la creaci√≥n de la Consulta (si a√∫n no existe), o puede desencadenar una actualizaci√≥n en segundo plano si los datos se consideran obsoletos.
- Iniciar una b√∫squeda cambia el estado de la Consulta, por lo que el Observador ser√° informado al respecto.
- El Observador luego realiza algunas optimizaciones y potencialmente notifica al componente sobre la actualizaci√≥n, que luego puede renderizar el nuevo estado.
- Despu√©s de que la Consulta haya terminado de ejecutarse, tambi√©n informar√° al Observador sobre eso.
Ten en cuenta que este es solo uno de los muchos flujos potenciales. Idealmente, los datos ya estar√≠an en la cach√© cuando se monta el componente; puedes obtener m√°s informaci√≥n al respecto en el apartado #17: Agregar datos iniciales a la cach√© de consultas.

Lo que es com√∫n en todos los flujos es que la mayor parte de la l√≥gica ocurre fuera de React (o Solid o Vue), y que cada actualizaci√≥n de la m√°quina de estados se propaga al Observador, quien luego decide si el componente tambi√©n debe ser informado.

Espero que ahora sea un poco m√°s claro c√≥mo funciona internamente React Query. Como siempre, no dudes en contactarme en Twitter si tienes alguna pregunta, o simplemente deja un comentario abajo.
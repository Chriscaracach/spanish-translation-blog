Por qu√© necesit√°s React Query
07.11.2023 - Dominik Dorfmeister (TkDodo)

No es ning√∫n secreto que me encanta React Query por c√≥mo simplifica la forma en que interactuamos con el estado as√≠ncrono en nuestras aplicaciones React. Y s√© que muchos colegas desarrolladores sienten lo mismo.

A veces, sin embargo, me encuentro con publicaciones que afirman que no necesitas utilizarlo para hacer algo tan "simple" como obtener datos de un servidor.

[quote]No necesitamos todas las funciones adicionales que React Query ofrece, as√≠ que no queremos agregar una biblioteca de terceros cuando podemos simplemente realizar una b√∫squeda de datos en un useEffect de manera igualmente sencilla.

Hasta cierto punto, creo que es un punto v√°lido: React Query te proporciona muchas funciones como almacenamiento en cach√©, reintentos, sondeos, sincronizaci√≥n de datos, precarga, ... y alrededor de un mill√≥n m√°s que ir√≠an mucho m√°s all√° del alcance de este art√≠culo. Est√° bien si no los necesitas, pero a√∫n as√≠ creo que esto no deber√≠a impedirte usar React Query.

Frameworks
Si est√°s utilizando un marco de trabajo que tiene una soluci√≥n incorporada para la obtenci√≥n y mutaci√≥n de datos, es posible que no necesites React Query.

Entonces, en lugar de eso, analicemos el ejemplo est√°ndar de realizar una b√∫squeda en un useEffect que surgi√≥ recientemente en Twitter y profundicemos en por qu√© podr√≠a ser una buena idea utilizar React Query tambi√©n en esas situaciones:

fetch-in-useEffect
Copyfetch-in-useEffect: copy code to clipboard
function Bookmarks({ category }) {
  const [data, setData] = useState([])
  const [error, setError] = useState()

  useEffect(() => {
    fetch(`${endpoint}/${category}`)
      .then(res => res.json())
      .then(d => setData(d))
      .catch(e => setError(e))
  }, [category])

  // Return JSX based on data and error state
}

Si crees que este c√≥digo es adecuado para casos de uso simples donde no necesitas funciones adicionales, perm√≠teme decirte que identifiqu√© de inmediato üêõ 5 errores ü™≤ escondidos en estas 10 l√≠neas de c√≥digo.

Quiz√°s t√≥mate uno o dos minutos y ve si puedes encontrarlos todos. Esperar√©...

Pista: No es el conjunto de dependencias. Eso est√° bien.

1. Condici√≥n de Carrera üèé
Hay razones por las cuales la documentaci√≥n oficial de React recomienda usar un framework o una biblioteca como React Query para la obtenci√≥n de datos. Mientras que realizar la solicitud de b√∫squeda puede ser un ejercicio bastante trivial, hacer que ese estado est√© disponible de manera predecible en tu aplicaci√≥n ciertamente no lo es.

El efecto est√° configurado de manera que se vuelve a buscar cada vez que cambia la categor√≠a, lo cual es ciertamente correcto. Sin embargo, las respuestas de la red pueden llegar en un orden diferente al que las enviaste. As√≠ que si cambias la categor√≠a de libros a pel√≠culas y la respuesta de pel√≠culas llega antes que la respuesta de libros, terminar√°s con datos incorrectos en tu componente.

[img](L√≠nea de tiempo que comienza a obtener libros, luego obtiene pel√≠culas. Las pel√≠culas se resuelven m√°s r√°pido, por lo que establecemos los datos de pel√≠culas (setData(movies)) antes de establecer los datos de libros (setData(books)).)

Al final, te quedar√° un estado inconsistente: tu estado local indicar√° que has seleccionado pel√≠culas, pero los datos que est√°s representando son en realidad de libros.

La documentaci√≥n de React dice que podemos solucionar esto con una funci√≥n de limpieza y un booleano de ignorar, as√≠ que hag√°moslo:

ignore-flag
Copyignore-flag: copy code to clipboard
function Bookmarks({ category }) {
  const [data, setData] = useState([])
  const [error, setError] = useState()

  useEffect(() => {
    let ignore = false
    fetch(`${endpoint}/${category}`)
      .then(res => res.json())
      .then(d => {
        if (!ignore) {
          setData(d)
        }
      .catch(e => {
        if (!ignore) {
          setError(e)
        }
      })
      return () => {
        ignore = true
      }
  }, [category])

  // Return JSX based on data and error state
}

Lo que sucede ahora es que la funci√≥n de limpieza del efecto se ejecuta cuando cambia la categor√≠a, estableciendo la bandera local de "ignorar" en true. Si despu√©s de eso llega una respuesta de b√∫squeda, ya no llamar√° a setState. Muy f√°cil.

2. Estado de carga üïê
No est√° presente en absoluto. No tenemos forma de mostrar una interfaz de usuario pendiente mientras se realizan las solicitudes, ni para la primera ni para las solicitudes posteriores. Entonces, ¬øagreguemos eso?

loading-state
Copyloading-state: copy code to clipboard
function Bookmarks({ category }) {
  const [isLoading, setIsLoading] = useState(true)
  const [data, setData] = useState([])
  const [error, setError] = useState()

  useEffect(() => {
    let ignore = false
    setIsLoading(true)
    fetch(`${endpoint}/${category}`)
      .then(res => res.json())
      .then(d => {
        if (!ignore) {
          setData(d)
        }
      .catch(e => {
        if (!ignore) {
          setError(e)
        }
      })
      .finally(() => {
        if (!ignore) {
          setIsLoading(false)
        }
      })
      return () => {
        ignore = true
      }
  }, [category])

  // Return JSX based on data and error state
}

3. Estado vac√≠o üóëÔ∏è
Inicializar los datos con un array vac√≠o parece una buena idea para evitar tener que verificar indefiniciones(undefined) todo el tiempo, pero ¬øqu√© pasa si recuperamos datos para una categor√≠a que a√∫n no tiene entradas, y de hecho recibimos un array vac√≠o? No tendr√≠amos forma de distinguir entre "sin datos a√∫n" y "ning√∫n dato en absoluto". El estado de carga que acabamos de introducir ayuda, pero a√∫n es mejor inicializar con indefinido(undefined):

empty-state
Copyempty-state: copy code to clipboard
function Bookmarks({ category }) {
  const [isLoading, setIsLoading] = useState(true)
  const [data, setData] = useState()
  const [error, setError] = useState()

  useEffect(() => {
    let ignore = false
    setIsLoading(true)
    fetch(`${endpoint}/${category}`)
      .then(res => res.json())
      .then(d => {
        if (!ignore) {
          setData(d)
        }
      .catch(e => {
        if (!ignore) {
          setError(e)
        }
      })
      .finally(() => {
        if (!ignore) {
          setIsLoading(false)
        }
      })
      return () => {
        ignore = true
      }
  }, [category])

  // Return JSX based on data and error state
}

4. Los datos y el error no se reinician cuando cambia la categor√≠a üîÑ
Tanto los datos como el error son variables de estado separadas, y no se reinician cuando cambia la categor√≠a. Esto significa que si una categor√≠a falla y cambiamos a otra que se recupera con √©xito, nuestro estado ser√°:

```javascript
data: datosDeLaCategoriaActual
error: errorDeLaCategoriaAnterior
```
El resultado depender√° de c√≥mo rendericemos JSX en funci√≥n de este estado. Si verificamos primero el error, renderizaremos la interfaz de usuario de error con el mensaje antiguo, aunque tengamos datos v√°lidos:

error-first
Copyerror-first: copy code to clipboard
return (
  <div>
    { error ? (
      <div>Error: {error.message}</div>
    ) : (
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.name}</div>
        ))}
      </ul>
    )}
  </div>
)

Si verificamos primero los datos, tenemos el mismo problema si la segunda solicitud falla. Si siempre renderizamos tanto el error como los datos, tambi√©n estamos mostrando informaci√≥n potencialmente desactualizada. üòî

Para solucionar esto, debemos restablecer nuestro estado local cuando cambia la categor√≠a:

reset-state
Copyreset-state: copy code to clipboard
function Bookmarks({ category }) {
  const [isLoading, setIsLoading] = useState(true)
  const [data, setData] = useState()
  const [error, setError] = useState()

  useEffect(() => {
    let ignore = false
    setIsLoading(true)
    fetch(`${endpoint}/${category}`)
      .then(res => res.json())
      .then(d => {
        if (!ignore) {
          setData(d)
          setError(undefined)
        }
      .catch(e => {
        if (!ignore) {
          setError(e)
          setData(undefined)
        }
      })
      .finally(() => {
        if (!ignore) {
          setIsLoading(false)
        }
      })
      return () => {
        ignore = true
      }
  }, [category])

  // Return JSX based on data and error state
}

5. Se ejecutar√° dos veces en StrictMode üî•üî•
Bueno, esto es m√°s una molestia que un error, pero definitivamente es algo que sorprende a los nuevos desarrolladores de React. Si tu aplicaci√≥n est√° envuelta en <React.StrictMode>, React llamar√° intencionalmente tu efecto dos veces en el modo de desarrollo para ayudarte a encontrar errores como funciones de limpieza faltantes.

Si quisi√©ramos evitar eso, tendr√≠amos que agregar otra "soluci√≥n de contorno con ref", lo cual no creo que valga la pena.


Bonus: Manejo de errores üö®
No inclu√≠ esto en la lista original de errores porque tendr√≠as el mismo problema con React Query: fetch no rechaza los errores HTTP, as√≠ que tendr√≠as que verificar res.ok y lanzar un error t√∫ mismo.

error-handling
Copyerror-handling: copy code to clipboard
function Bookmarks({ category }) {
  const [isLoading, setIsLoading] = useState(true)
  const [data, setData] = useState()
  const [error, setError] = useState()

  useEffect(() => {
    let ignore = false
    setIsLoading(true)
    fetch(`${endpoint}/${category}`)
      .then(res => {
        if (!res.ok) {
          throw new Error('Failed to fetch')
        }
        return res.json()
      })
      .then(d => {
        if (!ignore) {
          setData(d)
          setError(undefined)
        }
      .catch(e => {
        if (!ignore) {
          setError(e)
          setData(undefined)
        }
      })
      .finally(() => {
        if (!ignore) {
          setIsLoading(false)
        }
      })
      return () => {
        ignore = true
      }
  }, [category])

  // Return JSX based on data and error state
}

[quote]Por qu√© Fetch no rechaza las respuestas de error
Si deseas obtener m√°s informaci√≥n sobre por qu√© fetch se comporta de esa manera, echa un vistazo a este excelente art√≠culo de Artem Zakharchenko.

Nuestro peque√±o useEffect hook de "solo queremos obtener datos, ¬øqu√© tan dif√≠cil puede ser?" se convirti√≥ en un gran desorden de c√≥digo espagueti üçù tan pronto como tuvimos que considerar casos especiales y la gesti√≥n del estado. Entonces, ¬øcu√°l es la lecci√≥n aqu√≠?

La obtenci√≥n de datos es simple.
La gesti√≥n as√≠ncrona del estado no lo es.
Y aqu√≠ es donde entra React Query, porque React Query NO es una biblioteca de obtenci√≥n de datos, es un gestor de estado as√≠ncrono. Entonces, cuando dices que no lo necesitas para hacer algo tan simple como obtener datos de un punto final, en realidad tienes raz√≥n: incluso con React Query, necesitas escribir el mismo c√≥digo de obtenci√≥n que antes.

Pero a√∫n lo necesitas para hacer que ese estado est√© disponible de manera predecible en tu aplicaci√≥n de la manera m√°s f√°cil posible. Porque seamos honestos, no escrib√≠ ese c√≥digo de booleano de ignorar antes de usar React Query, y probablemente t√∫ tampoco lo hiciste. üòâ

Con React Query, el c√≥digo anterior se convierte en:

react-query
Copyreact-query: copy code to clipboard
function Bookmarks({ category }) {
  const { isLoading, data, error } = useQuery({
    queryKey: ['bookmarks', category],
    queryFn: () =>
      fetch(`${endpoint}/${category}`).then((res) => {
        if (!res.ok) {
          throw new Error('Failed to fetch')
        }
        return res.json()
      }),
  })

  // Return JSX based on data and error state
}

Esto abarca aproximadamente el 50% del c√≥digo espagueti mencionado anteriormente, y m√°s o menos la misma cantidad que el fragmento original y con errores. Y s√≠, esto aborda autom√°ticamente todos los errores que encontramos:

üêõ Errores
üèéÔ∏è No hay condici√≥n de carrera porque el estado siempre se almacena seg√∫n su entrada (categor√≠a).
üïê Obtienes estados de carga, datos y error de forma gratuita, incluyendo uniones discriminadas a nivel de tipo.
üóëÔ∏è Los estados vac√≠os est√°n claramente separados y se pueden mejorar a√∫n m√°s con funciones como placeholderData.
üîÑ No obtendr√°s datos ni errores de una categor√≠a anterior a menos que optes por ello.
üî• Las m√∫ltiples solicitudes se deduplican de manera eficiente, incluidas aquellas provocadas por StrictMode.

Entonces, si a√∫n piensas que no quieres usar React Query, me gustar√≠a desafiarte a probarlo en tu pr√≥ximo proyecto. Apuesto a que no solo terminar√°s con un c√≥digo m√°s resistente a casos especiales, sino tambi√©n m√°s f√°cil de mantener y ampliar. Y una vez que pruebes todas las funciones que ofrece, es probable que nunca mires hacia atr√°s.

[quote]Query.gg üîÆ
He estado trabajando en un nuevo curso oficial sobre React Query junto con ui.dev. Este curso te brindar√° una comprensi√≥n de los principios fundamentales tanto de c√≥mo funciona React Query bajo el cap√≥ como de c√≥mo escribir c√≥digo de React Query que escala. Si te gusta el contenido que he estado creando hasta ahora, te encantar√° query.gg.

[img](Query.gg - El curso oficial de React Query)

Bonus: Cancelaci√≥n
Muchas personas en Twitter mencionaron la falta de cancelaci√≥n de solicitudes en el fragmento original. No creo que eso sea necesariamente un error, solo una caracter√≠stica faltante. Por supuesto, React Query tambi√©n tiene esto cubierto con un cambio bastante sencillo:

cancellation
Copycancellation: copy code to clipboard
function Bookmarks({ category }) {
  const { isLoading, data, error } = useQuery({
    queryKey: ['bookmarks', category],
    queryFn: ({ signal }) =>
      fetch(`${endpoint}/${category}`, { signal }).then((res) => {
        if (!res.ok) {
          throw new Error('Failed to fetch')
        }
        return res.json()
      }),
  })

  // Return JSX based on data and error state
}

Simplemente toma la se√±al que recibes en queryFn, p√°sala a fetch y las solicitudes se abortar√°n autom√°ticamente cuando cambie la categor√≠a. üéâ

Eso es todo por hoy. No dudes en contactarme en Twitter si tienes alguna pregunta, o simplemente deja un comentario abajo. ‚¨áÔ∏è
He estado construyendo aplicaciones de React desde 2015. Desde entonces, React ha sido el mayor impulso de productividad individual para mi desarrollo sin duda alguna. El modelo declarativo de React para renderizar la interfaz de usuario basada en el estado simplific√≥ dr√°sticamente la forma en que pensaba acerca de la construcci√≥n de interfaces de usuario para la web. Tambi√©n me brind√≥ una gran manera de pensar en el estado que estaba muy por delante de lo que estaba haciendo antes con Angular.js y Backbone.

El eslogan de React es:

Una biblioteca de JavaScript para construir interfaces de usuario.

React hace un excelente trabajo al darte ese modelo de componente declarativo que pionero. No se puede construir una interfaz de usuario sin administrar alg√∫n estado (¬øest√° abierta o cerrada la lista desplegable?). Es por eso que React tiene la administraci√≥n del estado del componente.

La clave est√° en que hay mucho m√°s en las aplicaciones web que el estado local del componente. De hecho, la gran mayor√≠a del "estado" cargado en la t√≠pica aplicaci√≥n de React no es en realidad estado, sino una cach√© del estado que vino del servidor (que probablemente obtuvo de una capa de persistencia como una base de datos, por ejemplo). Si bien React siempre nos ha dado una buena manera de administrar el estado, no puede ocultar el hecho de que gran parte del estado que estamos administrando es en realidad una cach√© y sufre de los problemas de la cach√©.

Como dice la famosa cita de Phil Karlton:

Solo hay dos cosas dif√≠ciles en Ciencias de la Computaci√≥n: invalidar cach√© y poner nombres a las cosas.

En muchos sentidos, esto es una broma, pero la invalidaci√≥n de cach√© definitivamente es un problema desafiante. Hasta ahora, React no nos ha dado nada de forma predeterminada para manejar este problema, como lo demuestran la gran cantidad de bibliotecas y herramientas que se han construido alrededor de React para hacer esto m√°s f√°cil. Ya sea que est√©s usando Redux (toolkit), MobX, Apollo, React Query, SWR o algo m√°s, solo est√°s usando esas herramientas porque hay un problema com√∫n y compartido en el desarrollo web para el que React no tiene una respuesta incorporada:

Gesti√≥n del Abismo de la Red
¬øQu√© es el abismo de la red?
Esto es lo que quiero decir con el abismo de la red:

[img]Excalidraw diagram showing a box labeled client and a box labeled server with the words "Network Chasm" between them

Como desarrolladores web, escribimos c√≥digo que se ejecuta en el cliente (el navegador) y en el servidor. No tenemos control sobre la red. Es por eso que tenemos que pensar en la cach√© en primer lugar. Cuando nuestro componente de React se vuelve a renderizar mientras el usuario hace su selecci√≥n de taco üåÆ, necesitamos tener acceso sincr√≥nico a las opciones disponibles para ese taco en particular ü§§. Entonces hacemos solicitudes HTTP a trav√©s de la red y almacenamos esos valores en una cach√© en memoria a trav√©s del estado de React (o alguna biblioteca), para que est√©n disponibles para nuestro pr√≥ximo renderizado.

¬øSabes cu√°l es la causa n√∫mero uno de errores en aplicaciones tanto grandes como peque√±as?

El c√≥digo.

Ese abismo de la red es la fuente de una enorme cantidad de c√≥digo. Hacerlo bien es extremadamente dif√≠cil, pero estamos construyendo aplicaciones web, as√≠ que tenemos que intentarlo. Entonces, usando el poder de JavaScript, la moderna API fetch y algunas bibliotecas pr√°cticas, lanzamos un gancho de agarre sobre el abismo de la red a trav√©s de HTTP para obtener datos desde y hacia el backend:

[img] Similar diagram as above with a box above "Client" that says "SPA" and an arrow from that over the network chasm pointing to a box that says "Node/Rails/PHP/Java/.Net". The row is labeled "Client-side apps"

El c√≥digo necesario para que este gancho de agarre funcione se encuentra en el frontend. Para la recuperaci√≥n de datos, tienes que saber qu√© datos recuperar, y a menudo eso es un problema dif√≠cil porque nos gusta colocar nuestra recuperaci√≥n de datos con el c√≥digo que requiere los datos (reduce los errores/errores de datos demasiado al hacer las cosas de esta manera). Esto tiene el efecto desafortunado de no poder recuperar datos hasta que los componentes se han renderizado.

Agregue el deseo de implementar la divisi√≥n de c√≥digo para hacer que nuestra aplicaci√≥n cargue m√°s r√°pido y ahora no solo tiene que esperar a que se renderice el componente, sino que una vez que comienza a renderizar, tambi√©n tiene que recuperar el c√≥digo que realiza la recuperaci√≥n. Esto conduce a cascadas de red (y todos conocemos el peligro de las cascadas).

Desafortunadamente, la recuperaci√≥n de datos por s√≠ sola no puede resolver este problema. De hecho, incluso React Suspense para la recuperaci√≥n de datos no podr√° resolver este problema. Suspense tomar√° el lugar de muchas bibliotecas de recuperaci√≥n de datos al poder obtener los datos desde dentro de los componentes (y si a√∫n no se han almacenado en cach√©, activar√° la recuperaci√≥n de datos que se busca), pero si quieres evitar el efecto de cascada, tienes que empezar a recuperar los datos antes de que se renderice el c√≥digo para esos componentes.

Recuperaci√≥n m√°s temprana

Por eso estoy tan emocionado de que React Router vaya a resolver este problema al incorporar gran parte de lo que me encanta de Remix en React Router. Ryan lo explica en su publicaci√≥n Remixing React Router. Con el poder de las rutas anidadas del dise√±o y los cargadores (obtenci√≥n de datos) y las acciones (mutaci√≥n de datos), puedes desacoplar la recuperaci√≥n de datos de los componentes, pero a√∫n as√≠ beneficiarte mucho de la co-ubicaci√≥n. El c√≥digo de recuperaci√≥n puede que no est√© dentro del componente en este caso, pero debido a la naturaleza de las rutas anidadas del dise√±o, est√° bastante cerca.

Con estas caracter√≠sticas, pasamos de "tengo que renderizar para conocer los requisitos de datos" a "conozco los requisitos de datos desde la URL".

Adem√°s de esto, React Router ahora gestiona parte de esa brecha de red por ti, lo que significa que tienes mucho menos c√≥digo propio que preocuparte por los estados de carga/error. ¬°Tambi√©n significa que React Router puede manejar la validaci√≥n de cach√© por ti! Oh, y tambi√©n resubidas de formulario y condiciones de carrera (algunos de los problemas m√°s desafiantes en el desarrollo de UI). Y construir excelentes experiencias de usuario (como patrones de UI optimistas) nunca ha sido tan f√°cil. Esto reduce efectivamente la brecha de red para ti un poco:

[img]Similar diagram as before except now the SPA box extends slightly further over the network chasm and the row is labeled "Remixed Router apps"

¬øPodemos hacerlo mejor?
Tener esas caracter√≠sticas dentro de React Router ser√° un gran beneficio para cualquiera que busque simplificar su c√≥digo y acelerar su aplicaci√≥n. React Router ser√° un mejor amigo para cualquiera que use React Suspense para la obtenci√≥n de datos (a menos que tenga la infraestructura/compilador/enrutador que tiene Meta, supongo).

Pero podemos hacerlo a√∫n mejor. Incluso una vez que comiences a obtener datos desde el navegador antes, tus usuarios a√∫n tienen que esperar a que aparezcan y se ejecuten los paquetes de JavaScript iniciales antes de que puedan ver algo. Con React Router ayud√°ndote a manejar la carga y mutaci√≥n de datos, puedes eliminar mucho c√≥digo de gesti√≥n de estado (cach√©), pero todo sigue estando all√≠ en el navegador. Adem√°s, debido a que necesitamos el c√≥digo para obtener datos antes de obtener el c√≥digo que necesita los datos obtenidos, significa que ese c√≥digo ya no se divide.

¬øNo ser√≠a genial si pudi√©ramos simplemente mover todo ese c√≥digo fuera del navegador y en el servidor? ¬øNo es molesto tener que escribir una funci√≥n sin servidor cada vez que necesitas hablar con una base de datos o golpear una API que necesita tu clave privada? (s√≠ lo es). Estas son las cosas que React Server Components prometen hacer por nosotros, y definitivamente podemos esperar eso para la carga de datos, pero no hacen nada para las mutaciones, y ser√≠a genial mover ese c√≥digo fuera del navegador tambi√©n (y no tener que esperar a que sea lanzado).

Ingresa al escenario: Remix üíø

Para llevar realmente tu aplicaci√≥n al siguiente nivel, querr√°s renderizarla en el servidor. Y la mejor manera de hacerlo es usando Remix. Remix completa el puente a trav√©s del l√≠mite de red por ti de tal manera que ni siquiera tienes que pensarlo. Tomas todo tu c√≥digo de obtenci√≥n y mutaci√≥n de datos y lo mueves para que se exporte como funciones convencionales de "m√≥dulos de ruta de Remix" y de repente todo ese c√≥digo se queda en el servidor y Remix maneja todo el abismo de la red por ti:

[img]Similar to the diagrams before with the addition of a "Backend for frontend" row that shows Remix spanning over the client and network boundary into the Server and an arrow pointing to "Rails/PHP/Java/.Net"

Ahora tu aplicaci√≥n puede realmente volar ‚ö° porque el usuario ya no tiene que esperar a que se cargue JavaScript. La aplicaci√≥n est√° ah√≠ y lista para ellos (y gracias a la mejora progresiva, todos los enlaces y formularios funcionar√°n mientras se descarga JavaScript en segundo plano tambi√©n).

Y esto es genial, porque ahora puedes escribir c√≥digo que se ejecuta en el servidor, ya no tienes que preocuparte por hacer llamadas directas a la base de datos o golpear APIs con claves privadas. Tus cargadores y acciones solo se ejecutan en el servidor, por lo que pueden hacer lo que necesites. ¬°Bonita mejora de DX!

Tu aplicaci√≥n completa
Remix te da el poder del servidor, lo que significa que puede manejar tu aplicaci√≥n completa si es necesario. No todos quieren hacer las cosas de esta manera, pero debido a que tienes un backend que puede hablar directamente con bases de datos y servicios de terceros, puedes hacer que la estructura de tu aplicaci√≥n se parezca m√°s a esto:

[img]Similar to the diagrams before with the addition of a "Full Stack" row that shows Remix spanning over the entire client, network chasm, and server

Lo genial es que obtienes todos los beneficios de una brecha de red completamente gestionada al usar Remix, ya sea que vayas con 100% Remix o no, por lo que si est√°s contento con tu backend existente, ciertamente puedes seguir con eso.

Conclusi√≥n
El eslogan de React es:

Una biblioteca de JavaScript para construir interfaces de usuario.

Y hace un trabajo excelente en eso. React nunca ha prometido "gesti√≥n de la brecha de red", pero cada aplicaci√≥n web la necesita. Con Remix manejando esa brecha de red, finalmente tenemos un yang para el yin de React. Con una gran biblioteca de representaci√≥n y un excelente administrador de brechas de red, puede construir aplicaciones web mejores y m√°s r√°pidas con menos errores, c√≥digo m√°s simple y m√°s diversi√≥n.

En una nota personal, esto es lo que me hizo enamorarme de la construcci√≥n de aplicaciones web con Remix. El sitio web en el que est√°s leyendo esto hoy es el resultado de una reescritura en Remix. No ten√≠a idea de las cosas geniales que se convertir√≠an. Remix lo hizo posible porque cuando termin√© con las funciones b√°sicas, me di cuenta de que ten√≠a tiempo y capacidad para hacer mucho m√°s (lea m√°s sobre la reescritura de mi sitio aqu√≠). Remix me hizo sentir que pod√≠a decir "s√≠" a las ideas divertidas que ten√≠a y eso fue realmente refrescante.

Espero que esto te ayude en tu b√∫squeda de construir mejores sitios web. Mantente fresco üòé
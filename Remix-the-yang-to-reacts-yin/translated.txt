Remix: El "Yang" del "Yin" de React
24 de Marzo de 2022

He estado construyendo aplicaciones de React desde 2015. Desde entonces, React ha sido el mayor impulso de productividad individual para mi desarrollo, sin duda alguna. El modelo declarativo de React para renderizar una interfaz de usuario basada en el estado simplific√≥ dr√°sticamente la forma en la que yo pensaba acerca de la construcci√≥n de interfaces de usuario para la web. Tambi√©n me brind√≥ una gran manera de pensar en el estado que estaba muy por delante de lo que estaba haciendo antes con Angular.js y Backbone.

El eslogan de React es:

Una biblioteca de JavaScript para construir interfaces de usuario.

React hace √©ste trabajo de una manera excelente al darte ese modelo de componente declarativo del cual fue el precursor. No se puede construir una interfaz de usuario sin administrar alg√∫n estado (¬øest√° abierta o cerrada la lista desplegable?). Es por eso que React tiene una administraci√≥n del estado de componente.

La clave est√° en que hay mucho m√°s en las aplicaciones web que el estado local del componente. De hecho, la gran mayor√≠a del "estado" cargado en la t√≠pica aplicaci√≥n de React no es en realidad estado, sino una cach√© del estado que vino del servidor (que probablemente obtuvo de una capa de persistencia como una base de datos, por ejemplo). Si bien React siempre nos ha dado una buena manera de administrar el estado, no puede ocultar el hecho de que gran parte del estado que estamos administrando es en realidad una cach√© y sufre de los problemas de la cach√©.

Como dice la famosa cita de Phil Karlton:

"Solo hay dos cosas dif√≠ciles en Ciencias de la Computaci√≥n: invalidar cach√© y poner nombres a las cosas."

En muchos sentidos, esto es una broma, pero la invalidaci√≥n de cach√© definitivamente es un problema desafiante. Hasta ahora, React no nos ha dado nada de forma predeterminada para manejar este problema, como lo demuestran la gran cantidad de bibliotecas y herramientas que se han construido alrededor de React para hacer esto m√°s f√°cil. Ya sea que est√©s usando Redux (toolkit), MobX, Apollo, React Query, SWR o algo m√°s, solo est√°s usando esas herramientas porque hay un problema com√∫n y compartido en el desarrollo web para el que React no tiene una respuesta incorporada:

[Gesti√≥n del Abismo de la Red] IMPORTANT


¬øQu√© es el abismo de la red?
Esto es lo que quiero decir con el abismo de la red:

[img]Diagrama que muestra una "caja" con un texto "Client" y una caja con un texto "Servidor", entre medio de las dos est√° la palabra "Abismo de la Red"

Como desarrolladores web, escribimos c√≥digo que se ejecuta en el cliente (el navegador) y en el servidor. No tenemos control sobre la red. Es por eso que tenemos que pensar en la cach√© en primer lugar. Cuando nuestro componente de React se vuelve a renderizar mientras el usuario hace su selecci√≥n de taco üåÆ, necesitamos tener acceso sincr√≥nico a las opciones disponibles para ese taco en particular ü§§. Entonces hacemos solicitudes HTTP a trav√©s de la red y almacenamos esos valores en una cach√© en memoria a trav√©s del estado de React (o alguna biblioteca), para que est√©n disponibles para nuestro pr√≥ximo renderizado.

¬øSabes cu√°l es la causa n√∫mero uno de errores en aplicaciones tanto grandes como peque√±as?

El c√≥digo.

Ese abismo de la red es la fuente de una enorme cantidad de c√≥digo. Hacerlo bien es extremadamente dif√≠cil, pero estamos construyendo aplicaciones web, as√≠ que tenemos que intentarlo. Entonces, usando el poder de JavaScript, la moderna API fetch y algunas bibliotecas pr√°cticas, lanzamos un gancho de agarre ("grappling hook") sobre el abismo de la red a trav√©s de peticiones HTTP para obtener datos desde y hacia el backend:

[img] Diagrama similar al de arriba pero arriba de "Cliente" dice "SPA" y una flecha que sale de esa caja y apunta a otra caja arriba de "servidor" que dice "Node/Rails/PHP/Java/.Net". El diagrama tiene la inscripci√≥n que dice "Aplicaciones del lado del Cliente"

El c√≥digo necesario para que este gancho de agarre (grappling hook) funcione se encuentra en el frontend. Para la recuperaci√≥n de datos, tienes que saber qu√© datos recuperar, y a menudo eso es un problema dif√≠cil porque nos gusta co-locar nuestra recuperaci√≥n de datos con el c√≥digo que requieren los datos. √âsto tiene el efecto desafortunado de no poder recuperar datos hasta que los componentes se han renderizado.

Agregue a todo √©sto el deseo de implementar la divisi√≥n de c√≥digo para hacer que nuestra aplicaci√≥n cargue m√°s r√°pido y ahora no solo tiene que esperar a que se renderice el componente, sino que una vez que comienza a renderizarse, tambi√©n tiene que obtener(fetch) el c√≥digo que realiza la recuperaci√≥n(fetch). Esto conduce a cascadas de red (y todos conocemos el peligro de las cascadas).

Desafortunadamente, la obtenci√≥n de datos por s√≠ sola no puede resolver este problema. De hecho, incluso React Suspense para la obtenci√≥n de datos no podr√° resolver este problema. Suspense tomar√° el lugar de muchas bibliotecas de obtenci√≥n de datos al poder obtener los datos desde dentro de los componentes (y si a√∫n no se han almacenado en cach√©, activar√° la recuperaci√≥n de datos que se busca), pero si quieres evitar el efecto de cascada, tienes que empezar a obtener los datos antes de que se renderice el c√≥digo para esos componentes.

Recuperaci√≥n m√°s temprana

Por eso estoy tan emocionado de que React Router vaya a resolver este problema al incorporar gran parte de lo que me encanta de Remix. Ryan lo explica en su publicaci√≥n Remixing React Router. Con el poder de las rutas anidadas del dise√±o y los cargadores (obtenci√≥n de datos) y las acciones (mutaci√≥n de datos), puedes desacoplar la obtenci√≥n de datos de los componentes, pero a√∫n as√≠ beneficiarte mucho de la co-ubicaci√≥n. El c√≥digo de recuperaci√≥n puede que no est√© dentro del componente en este caso, pero debido a la naturaleza de las rutas anidadas del dise√±o, est√° bastante cerca.

Con estas caracter√≠sticas, pasamos de "tengo que renderizar para conocer los requisitos de datos" a "conozco los requisitos de los datos desde la URL".

Adem√°s de esto, React Router ahora gestiona parte de esa brecha de red por ti, lo que significa que tienes mucho menos c√≥digo propio del que preocuparte por los estados de carga/error. ¬°Tambi√©n significa que React Router puede manejar la validaci√≥n de cach√© por ti! Oh, y tambi√©n resubidas de formularios. Y construir excelentes experiencias de usuario (como patrones optimistas de UI) nunca ha sido tan f√°cil. Esto reduce efectivamente la brecha de red para ti un poco:

[img] Diagrama similar al anterior pero ahora la cajca SPA se extiende un poco encima de "Abismo de la Red" y la fila tiene el nombre de "aplicaciones Router-Remixadas".

¬øPodemos hacerlo mejor?
Tener esas caracter√≠sticas dentro de React Router ser√° un gran beneficio para cualquiera que busque simplificar su c√≥digo y acelerar su aplicaci√≥n. React Router ser√° un mejor amigo para cualquiera que use React Suspense para la obtenci√≥n de datos (a menos que tenga la infraestructura/compilador/enrutador que tiene Meta, supongo).

Pero podemos hacerlo a√∫n mejor. Incluso una vez que comiences a obtener  m√°s temprani los datos desde el navegador, tus usuarios a√∫n tienen que esperar a que aparezcan y se ejecuten los paquetes de JavaScript iniciales antes de que puedan ver algo. Con React Router ayud√°ndote a manejar la carga y mutaci√≥n de datos, puedes eliminar mucho c√≥digo de gesti√≥n de estado (cach√©), pero todo sigue estando all√≠ en el navegador. Adem√°s, debido a que necesitamos el c√≥digo para obtener datos antes de obtener el c√≥digo que necesita los datos obtenidos, significa que ese c√≥digo ya no se divide.

¬øNo ser√≠a genial si pudi√©ramos simplemente mover todo ese c√≥digo fuera del navegador y en el servidor? ¬øNo es molesto tener que escribir una funci√≥n sin servidor cada vez que necesitas hablar con una base de datos o golpear una API que necesita tu clave privada? (s√≠). Estas son las cosas que React Server Components prometen hacer por nosotros, y definitivamente podemos esperar eso para la carga de datos, pero no hacen nada para las mutaciones, y ser√≠a genial mover ese c√≥digo fuera del navegador tambi√©n (y no tener que esperar a que sea lanzado).

Ingresa al escenario: Remix üíø

Para llevar realmente tu aplicaci√≥n al siguiente nivel, querr√°s renderizarla en el servidor. Y la mejor manera de hacerlo es usando Remix. Remix completa el puente a trav√©s del l√≠mite de red por ti de tal manera que ni siquiera tienes que pensarlo. Tomas todo tu c√≥digo de obtenci√≥n y mutaci√≥n de datos y lo mueves para que se exporte como funciones convencionales de "m√≥dulos de ruta de Remix" y de repente todo ese c√≥digo se queda en el servidor y Remix maneja todo el abismo de la red por ti:

[img] Diagrama similar a los anteriores, con el agregado de la fila "Backend para Frontend" que muestra a Remix apareciendo encima de "client". con una flecha apuntando a la caja de "Rails/PHP/etc... que ahora es m√°s peque√±a.

Ahora tu aplicaci√≥n puede realmente volar ‚ö° porque el usuario ya no tiene que esperar a que se cargue JavaScript. La aplicaci√≥n est√° ah√≠ y lista para ellos (y gracias a la mejora progresiva, todos los enlaces y formularios funcionar√°n mientras se descarga JavaScript en segundo plano tambi√©n).

Y esto es genial, porque ahora puedes escribir c√≥digo que se ejecuta en el servidor, ya no tienes que preocuparte por hacer llamadas directas a la base de datos o golpear APIs con claves privadas. Tus cargadores y acciones solo se ejecutan en el servidor, por lo que pueden hacer lo que necesites. ¬°Bonita mejora de DX (Experiencia del desarrollador)!

Tu aplicaci√≥n completa
Remix te da el poder del servidor, lo que significa que puede manejar tu aplicaci√≥n completa si es necesario. No todos quieren hacer las cosas de esta manera, pero debido a que tienes un backend que puede hablar directamente con bases de datos y servicios de terceros, puedes hacer que la estructura de tu aplicaci√≥n se parezca m√°s a esto:

[img] Diagrama similar a los anteriores, con el agregado de la fila "Full Stack" que muestra a Remix apareciendo encima de "cliente", "Abismo de la red" y "Servidor", por completo.


Lo genial es que obtienes todos los beneficios de una brecha de red completamente gestionada al usar Remix, ya sea que vayas 100% con Remix o no, por lo que si est√°s contento con tu backend existente, ciertamente puedes seguir con eso.

Conclusi√≥n
El eslogan de React es:

Una biblioteca de JavaScript para construir interfaces de usuario.


Y hace un trabajo excelente en eso. React nunca ha prometido "gesti√≥n de la brecha de red", pero cada aplicaci√≥n web la necesita. Con Remix manejando esa brecha de red, finalmente tenemos un yang para el yin de React. Con una gran biblioteca de representaci√≥n y un excelente administrador de brechas de red, puede construir aplicaciones web mejores y m√°s r√°pidas con menos errores, c√≥digo m√°s simple y m√°s diversi√≥n.

En una nota personal, √©sto es lo que me hizo enamorarme de la construcci√≥n de aplicaciones web con Remix. El sitio web en el que est√°s leyendo esto hoy (El blog de Kent C. Dodds) es el resultado de una reescritura en Remix. No ten√≠a idea de las cosas geniales que se convertir√≠an. Remix lo hizo posible porque cuando termin√© con las funciones b√°sicas, me di cuenta de que ten√≠a tiempo y capacidad para hacer mucho m√°s (lea m√°s sobre la reescritura de mi sitio aqu√≠). Remix me hizo sentir que pod√≠a decir "s√≠" a las ideas divertidas que ten√≠a y eso fue realmente refrescante.

Espero que esto te ayude en tu b√∫squeda de construir mejores sitios web. Mantente fresco üòé
React Query y React Context - Dominik Dorfmeister (TkDodo) - 22.07.2023

Una de las mejores caracter칤sticas de React Query es que puedes usar una consulta donde quieras en tu 치rbol de componentes: Tu componente <ProductTable> puede obtener sus propios datos, colocados en el mismo lugar donde los necesitas:

[code]
function ProductTable() {
  const productQuery = useProductQuery()

  if (productQuery.data) {
    return <table>...</table>
  }

  if (productQuery.isError) {
    return <ErrorMessage error={productQuery.error} />
  }

  return <SkeletonLoader />
}

Para m칤, esto es genial porque hace que el ProductTable est칠 desacoplado e independiente, es responsable de leer sus propias dependencias: los datos de los productos. Si ya est치n en la cach칠, perfecto, simplemente los leeremos. Si no es as칤, iremos a buscarlos. Y podemos ver patrones similares surgir con los Componentes del Servidor de React. Ellos tambi칠n nos permiten obtener datos directamente dentro de nuestros componentes. Ya no hay divisiones arbitrarias entre componentes con estado y sin estado, o entre componentes inteligentes y tontos.

Poder obtener datos directamente en un componente, donde lo necesitas, es inmensamente 칰til. Literalmente podemos tomar el componente ProductTable y moverlo a cualquier lugar de nuestra aplicaci칩n, y simplemente funcionar치. El componente es muy resistente al cambio, que es la raz칩n principal por la cual abogo por acceder a tu consulta directamente donde sea necesario (a trav칠s de un hook personalizado), tanto en el punto 10: React Query como gestor de estado, como en el punto 21: Pensando en React Query.

Sin embargo, no es una soluci칩n infalible, ya que conlleva compromisos. Esto no deber칤a ser sorprendente, porque al final del d칤a, todo implica compromisos. Pero, 쯤u칠 estamos intercambiando exactamente aqu칤?

Siendo autosuficiente
Para que un componente sea aut칩nomo, significa que debe manejar casos en los que los datos de la consulta no est치n disponibles todav칤a, en particular: los estados de carga y error. Esto no es un gran problema para nuestro componente <ProductTable>, porque muy a menudo, cuando se carga por primera vez, en realidad mostrar치 ese <SkeletonLoader />.

Pero hay muchas otras situaciones en las que solo queremos leer informaci칩n de algunas partes de nuestra consulta, donde sabemos que la consulta ya se ha utilizado m치s arriba en el 치rbol. Por ejemplo, podr칤amos tener una userQuery que contiene informaci칩n sobre el usuario que ha iniciado sesi칩n:

[code]
export const useUserQuery = (id: number) => {
  return useQuery({
    queryKey: ['user', id],
    queryFn: () => fetchUserById(id),
  })
}
export const useCurrentUserQuery = () => {
  const id = useCurrentUserId()

  return useUserQuery(id)
}

Probablemente utilizaremos esta consulta bastante temprano en nuestro 치rbol de componentes, para verificar qu칠 derechos tiene el usuario que ha iniciado sesi칩n, y esto podr칤a determinar si realmente podemos ver la p치gina o no. Es informaci칩n esencial que queremos en todas partes de nuestra p치gina.

Ahora m치s abajo en el 치rbol, podr칤amos tener un componente que quiera mostrar el nombre de usuario, que podemos obtener del gancho useCurrentUserQuery:

[code]
function UserNameDisplay() {
  const { data } = useCurrentUserQuery()
  return <div>User: {data.userName}</div>
}

Por supuesto, TypeScript no nos dejar치 hacerlo, porque los datos podr칤an ser potencialmente indefinidos. Pero nosotros ya sabemos: no puede ser indefinido, porque en nuestra situaci칩n, UserNameDisplay no se renderizar치 sin que la consulta ya se haya iniciado m치s arriba en el 치rbol.

Ese es un peque침o dilema. 쯈ueremos simplemente silenciar a TS aqu칤 y hacer data!.userName, porque sabemos que estar치 definido? 쯆ptamos por la seguridad y hacemos data?.userName (lo cual es posible aqu칤, pero puede no ser tan f치cil de lograr en otras situaciones)? 쮸gregamos simplemente una protecci칩n: if (!data) return null? 쯆 a침adimos manejo adecuado de carga y errores a las 25 ubicaciones en las que llamamos a useCurrentUserQuery?

Para ser honesto, creo que todas esas formas son un tanto sub칩ptimas. No quiero llenar mi base de c칩digo con comprobaciones que "nunca deber칤an ocurrir" (seg칰n mi conocimiento actual). Pero tampoco quiero ignorar TypeScript, porque (como es habitual), TS tiene raz칩n.

Una dependencia impl칤cita
Nuestro problema surge del hecho de que tenemos una dependencia impl칤cita: una dependencia que solo existe en nuestra mente, en nuestro conocimiento de la estructura de la aplicaci칩n, pero que no es visible en el propio c칩digo.

A pesar de que sabemos que podemos llamar con seguridad a useCurrentUserQuery sin tener que comprobar si los datos no est치n definidos, ning칰n an치lisis est치tico puede verificar esto. Nuestros compa침eros de trabajo podr칤an no saberlo. Yo mismo podr칤a no saberlo dentro de 3 meses.

La parte m치s peligrosa es que podr칤a ser cierto ahora, pero podr칤a dejar de serlo en el futuro. Podemos decidir renderizar otra instancia de UserNameDisplay en alg칰n lugar de nuestra aplicaci칩n, donde es posible que no tengamos datos de usuario en la cach칠, o donde podr칤amos tener datos de usuario en la cach칠 condicionalmente, por ejemplo, si hemos visitado una p치gina diferente antes.

Esto es completamente opuesto al componente <ProductTable>: en lugar de ser resistente al cambio, se vuelve propenso a errores en las refactorizaciones. No esperar칤amos que el componente UserNameDisplay se rompiera solo porque movemos algunos componentes aparentemente no relacionados...

Hacerlo expl칤cito
La soluci칩n es, por supuesto, hacer que la dependencia sea expl칤cita. Y no hay mejor manera de hacerlo que con React Context:

Contexto de React
Existe un mito bastante extendido sobre el Contexto de React, as칤 que aclaremos esto: No, el Contexto de React no es un administrador de estado. Puede convertirse en una soluci칩n aparentemente buena para la gesti칩n de estado cuando se combina con useState o useReducer, pero para ser honesto, nunca me ha gustado realmente este enfoque, ya que he tenido situaciones problem치ticas como estas demasiado a menudo:

[tweet]

Entonces, lo m치s probable es que est칠s mejor utilizando una herramienta dedicada. Mark Erikson, el mantenedor de Redux y autor de publicaciones de blog muy extensas, tiene un buen art칤culo sobre ese tema: Respuestas en Blog: Por qu칠 el Contexto de React no es una herramienta de "gesti칩n de estado" (y por qu칠 no reemplaza a Redux).

Mi tuit ya lo menciona: el Contexto de React es una herramienta de inyecci칩n de dependencias. Te permite definir qu칠 "cosas" necesita tu componente para funcionar, y cualquier componente padre es responsable de proporcionar esa informaci칩n.

Esto es conceptualmente lo mismo que el prop-drilling, que es el proceso de pasar props a trav칠s de m칰ltiples capas. El Contexto te permite hacer lo mismo: tomar algunos valores y pasarlos como props a los hijos, excepto que puedes evitar algunas capas:

[img]
[alt]츼rbol de componentes que muestra la transferencia de props a trav칠s de dos componentes vs. la transferencia de contexto donde el nieto puede leerlo directamente.

Con el contexto, simplemente te saltas al intermediario. En nuestro ejemplo de useCurrentUserQuery, puede ayudarnos a hacer que esa dependencia sea expl칤cita: en lugar de leer useCurrentUserQuery directamente en todos los componentes donde queremos evitar la comprobaci칩n de disponibilidad de datos, lo leemos desde el Contexto de React. Y ese contexto ser치 llenado por el componente padre que realmente realiza la primera comprobaci칩n:

[code]
const CurrentUserContext = React.CreateContext<User | null>(null)

export const useCurrentUserContext = () => {
  return React.useContext(CurrentUserContext)
}

export const CurrentUserContextProvider = ({
  children,
}: {
  children: React.ReactNode
}) => {
  const currentUserQuery = useCurrentUserQuery()

  if (currentUserQuery.isLoading) {
    return <SkeletonLoader />
  }

  if (currentUserQuery.isError) {
    return <ErrorMessage error={currentUserQuery.error} />
  }

  return (
    <CurrentUserContext.Provider value={currentUserQuery.data}>
      {children}
    </CurrentUserContext.Provider>
  )
}

Aqu칤, tomamos la currentUserQuery y colocamos los datos resultantes en el Contexto de React, si existen (eliminando los estados de carga y error de antemano). Luego podemos leer desde ese contexto de manera segura en nuestros componentes hijos, por ejemplo, en el componente UserNameDisplay:

[code]
function UserNameDisplay() {
  const data = useCurrentUserContext()
  return <div>User: {data.username}</div>
}

Con eso, hemos convertido nuestra dependencia impl칤cita (sabemos que los datos se han obtenido m치s arriba en el 치rbol) en una dependencia expl칤cita. Siempre que alguien vea UserNameDisplay, sabr치 que necesitan tener los datos proporcionados desde CurrentUserContextProvider. Esto es algo que puedes tener en cuenta al refactorizar. Si cambias d칩nde se renderiza el Proveedor, tambi칠n sabr치s que afectar치 a todos los componentes hijos que utilicen ese contexto. Esto es algo que no puedes saber cuando un componente solo utiliza una consulta, porque las consultas suelen ser globales en toda tu aplicaci칩n, y los datos podr칤an o no existir.

Agradando a TypeScript
A pesar de todo, TypeScript a칰n no estar치 muy contento, porque el Contexto de React est치 dise침ado para funcionar incluso sin un Proveedor, en cuyo caso te proporcionar치 el valor predeterminado del Contexto, que en nuestro caso es nulo. Dado que nunca queremos que useCurrentUserContext funcione en una situaci칩n en la que estemos fuera de un Proveedor, podemos agregar una invariante a nuestro hook personalizado:

[code]
export const useCurrentUserContext = () => {
  const currentUser = React.useContext(CurrentUserContext)
  if (!currentUser) {
    throw new Error('CurrentUserContext: No value provided')
  }

  return currentUser
}

Este m칠todo asegura que fallaremos de manera r치pida y con un buen mensaje de error si alguna vez accedemos accidentalmente a useCurrentUserContext en el lugar equivocado. Y con esto, TypeScript inferir치 el valor "User" para nuestro hook personalizado, por lo que podemos usarlo de manera segura y acceder a sus propiedades.

Sincronizaci칩n de Estado
Podr칤as estar pensando: 쯅o es esto una "sincronizaci칩n de estado" - copiar un valor de React Query y ponerlo en otro m칠todo de distribuci칩n de estado?

La respuesta es: 춰No, no lo es! La 칰nica fuente de verdad sigue siendo la consulta (query). No hay forma de cambiar el valor de contexto aparte del Proveedor (Provider), que siempre reflejar치 los datos m치s recientes que tiene la consulta. Nada se copia aqu칤 y nada puede desincronizarse. Pasar datos desde React Query como una propiedad (prop) a un componente hijo tampoco es una "sincronizaci칩n de estado", y dado que el contexto es similar a la transmisi칩n de propiedades (prop drilling), tampoco es una "sincronizaci칩n de estado".

Cascadas de Solicitudes
Nada est치 exento de desventajas, y esta t칠cnica tampoco lo est치. Espec칤ficamente, podr칤a crear cascadas de solicitudes en la red, ya que el 치rbol de componentes se detendr치 en su renderizaci칩n (se "suspende") en el Proveedor (Provider), por lo que los componentes secundarios no se renderizar치n y no podr치n realizar solicitudes a la red, incluso si no est치n relacionados.

Principalmente considerar칤a este enfoque para los datos que son obligatorios para mi sub-치rbol: la informaci칩n del usuario es un buen ejemplo, ya que de todos modos podr칤amos no saber qu칠 renderizar sin esos datos.

Suspense
Hablando sobre Suspense: S칤, puedes lograr una arquitectura similar con React Suspense, y s칤, tiene la misma desventaja: posibles cascadas de solicitudes, de las cuales ya he hablado en el punto #17: Alimentando la Cach칠 de Consultas (Query Cache).

Un problema es que en la versi칩n principal actual (v4), usar "suspense: true" en tu consulta (query) no estrechar치 el tipo de datos, porque todav칤a hay formas de desactivar la consulta y evitar que se ejecute.

Sin embargo, en la versi칩n v5, habr치 un gancho expl칤cito llamado "useSuspenseQuery", donde los datos est치n garantizados para estar definidos una vez que el componente se renderiza. Con eso, podemos hacer:

[code]
function UserNameDisplay() {
  const { data } = useSuspenseQuery(...)
  return <div>User: {data.username}</div>
}

y TypeScript estar치 contento al respecto. 游꿀
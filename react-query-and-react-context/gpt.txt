React Query y React Context - Dominik Dorfmeister (TkDodo) - 22.07.2023

Una de las mejores caracter√≠sticas de React Query es que puedes usar una consulta donde quieras en tu √°rbol de componentes: Tu componente <ProductTable> puede obtener sus propios datos, colocados en el mismo lugar donde los necesitas:

[code]
function ProductTable() {
  const productQuery = useProductQuery()

  if (productQuery.data) {
    return <table>...</table>
  }

  if (productQuery.isError) {
    return <ErrorMessage error={productQuery.error} />
  }

  return <SkeletonLoader />
}

Para m√≠, esto es genial porque hace que el ProductTable est√© desacoplado e independiente: es responsable de leer sus propias dependencias: los datos de productos. Si ya est√°n en la cach√©, perfecto, simplemente los leeremos. Si no es as√≠, iremos a buscarlos. Y podemos ver patrones similares surgir con los Componentes del Servidor de React. Ellos tambi√©n nos permiten obtener datos directamente dentro de nuestros componentes. Ya no hay divisiones arbitrarias entre componentes con estado y sin estado, o entre componentes inteligentes y tontos.

Poder obtener datos directamente en un componente, donde lo necesitas, es inmensamente √∫til. Literalmente podemos tomar el componente ProductTable y moverlo a cualquier lugar de nuestra aplicaci√≥n, y simplemente funcionar√°. El componente es muy resistente al cambio, que es la raz√≥n principal por la cual abogo por acceder a tu consulta directamente donde sea necesario (a trav√©s de un gancho personalizado), tanto en el punto 10: React Query como gestor de estado, como en el punto 21: Pensando en React Query.

Sin embargo, no es una soluci√≥n infalible, ya que conlleva compromisos. Esto no deber√≠a ser sorprendente, porque al final del d√≠a, todo implica compromisos. Pero, ¬øqu√© estamos intercambiando exactamente aqu√≠?

Siendo autosuficiente
Para que un componente sea aut√≥nomo, significa que debe manejar casos en los que los datos de la consulta no est√°n disponibles todav√≠a, en particular: los estados de carga y error. Esto no es un gran problema para nuestro componente <ProductTable>, porque muy a menudo, cuando se carga por primera vez, en realidad mostrar√° ese <SkeletonLoader />.

Pero hay muchas otras situaciones en las que solo queremos leer informaci√≥n de algunas partes de nuestra consulta, donde sabemos que la consulta ya se ha utilizado m√°s arriba en el √°rbol. Por ejemplo, podr√≠amos tener una userQuery que contiene informaci√≥n sobre el usuario que ha iniciado sesi√≥n:

[code]
export const useUserQuery = (id: number) => {
  return useQuery({
    queryKey: ['user', id],
    queryFn: () => fetchUserById(id),
  })
}
export const useCurrentUserQuery = () => {
  const id = useCurrentUserId()

  return useUserQuery(id)
}

Probablemente utilizaremos esta consulta bastante temprano en nuestro √°rbol de componentes, para verificar qu√© derechos tiene el usuario que ha iniciado sesi√≥n, y esto podr√≠a determinar si realmente podemos ver la p√°gina o no. Es informaci√≥n esencial que queremos en todas partes de nuestra p√°gina.

Ahora m√°s abajo en el √°rbol, podr√≠amos tener un componente que quiera mostrar el nombre de usuario, que podemos obtener del gancho useCurrentUserQuery:

[code]
function UserNameDisplay() {
  const { data } = useCurrentUserQuery()
  return <div>User: {data.userName}</div>
}

Por supuesto, TypeScript no nos dejar√° hacerlo, porque los datos podr√≠an ser potencialmente indefinidos. Pero nosotros sabemos mejor: no puede ser indefinido, porque en nuestra situaci√≥n, UserNameDisplay no se renderizar√° sin que la consulta ya se haya iniciado m√°s arriba en el √°rbol.

Eso es un poco un dilema. ¬øQueremos simplemente silenciar a TS aqu√≠ y hacer data!.userName, porque sabemos que estar√° definido? ¬øOptamos por la seguridad y hacemos data?.userName (lo cual es posible aqu√≠, pero puede no ser tan f√°cil de lograr en otras situaciones)? ¬øAgregamos simplemente una protecci√≥n: if (!data) return null? ¬øO a√±adimos manejo adecuado de carga y errores a las 25 ubicaciones en las que llamamos a useCurrentUserQuery?

Para ser honesto, creo que todas esas formas son un tanto sub√≥ptimas. No quiero llenar mi base de c√≥digo con comprobaciones que "nunca deber√≠an ocurrir" (seg√∫n mi conocimiento actual). Pero tampoco quiero ignorar TypeScript, porque (como es habitual), TS tiene raz√≥n.

Una dependencia impl√≠cita
Nuestro problema surge del hecho de que tenemos una dependencia impl√≠cita: una dependencia que solo existe en nuestra mente, en nuestro conocimiento de la estructura de la aplicaci√≥n, pero que no es visible en el propio c√≥digo.

A pesar de que sabemos que podemos llamar con seguridad a useCurrentUserQuery sin tener que comprobar si los datos no est√°n definidos, ning√∫n an√°lisis est√°tico puede verificar esto. Nuestros compa√±eros de trabajo podr√≠an no saberlo. Yo mismo podr√≠a no saberlo dentro de 3 meses.

La parte m√°s peligrosa es que podr√≠a ser cierto ahora, pero podr√≠a dejar de serlo en el futuro. Podemos decidir renderizar otra instancia de UserNameDisplay en alg√∫n lugar de nuestra aplicaci√≥n, donde es posible que no tengamos datos de usuario en la cach√©, o donde podr√≠amos tener datos de usuario en la cach√© condicionalmente, por ejemplo, si hemos visitado una p√°gina diferente antes.

Esto es completamente opuesto al componente <ProductTable>: en lugar de ser resistente al cambio, se vuelve propenso a errores en las refactorizaciones. No esperar√≠amos que el componente UserNameDisplay se rompiera solo porque movemos algunos componentes aparentemente no relacionados...

Hacerlo expl√≠cito
La soluci√≥n es, por supuesto, hacer que la dependencia sea expl√≠cita. Y no hay mejor manera de hacerlo que con React Context:

Contexto de React
Existe un mito bastante extendido sobre el Contexto de React, as√≠ que aclaremos esto: No, el Contexto de React no es un administrador de estado. Puede convertirse en una soluci√≥n aparentemente buena para la gesti√≥n de estado cuando se combina con useState o useReducer, pero para ser honesto, nunca me ha gustado realmente este enfoque, ya que he tenido situaciones problem√°ticas como estas demasiado a menudo:

[tweet]

Entonces, lo m√°s probable es que est√©s mejor utilizando una herramienta dedicada. Mark Erikson, el mantenedor de Redux y autor de publicaciones de blog muy extensas, tiene un buen art√≠culo sobre ese tema: Respuestas en Blog: Por qu√© el Contexto de React no es una herramienta de "gesti√≥n de estado" (y por qu√© no reemplaza a Redux).

Mi tuit ya lo menciona: el Contexto de React es una herramienta de inyecci√≥n de dependencias. Te permite definir qu√© "cosas" necesita tu componente para funcionar, y cualquier componente padre es responsable de proporcionar esa informaci√≥n.

Esto es conceptualmente lo mismo que el prop-drilling, que es el proceso de pasar props a trav√©s de m√∫ltiples capas. El Contexto te permite hacer lo mismo: tomar algunos valores y pasarlos como props a los hijos, excepto que puedes evitar algunas capas:

[img]
[alt]√Årbol de componentes que muestra la transferencia de props a trav√©s de dos componentes vs. la transferencia de contexto donde el nieto puede leerlo directamente

Con el contexto, simplemente te saltas al intermediario. En nuestro ejemplo de useCurrentUserQuery, puede ayudarnos a hacer que esa dependencia sea expl√≠cita: en lugar de leer useCurrentUserQuery directamente en todos los componentes donde queremos evitar la comprobaci√≥n de disponibilidad de datos, lo leemos desde el Contexto de React. Y ese contexto ser√° llenado por el componente padre que realmente realiza la primera comprobaci√≥n:

[code]
const CurrentUserContext = React.CreateContext<User | null>(null)

export const useCurrentUserContext = () => {
  return React.useContext(CurrentUserContext)
}

export const CurrentUserContextProvider = ({
  children,
}: {
  children: React.ReactNode
}) => {
  const currentUserQuery = useCurrentUserQuery()

  if (currentUserQuery.isLoading) {
    return <SkeletonLoader />
  }

  if (currentUserQuery.isError) {
    return <ErrorMessage error={currentUserQuery.error} />
  }

  return (
    <CurrentUserContext.Provider value={currentUserQuery.data}>
      {children}
    </CurrentUserContext.Provider>
  )
}

Aqu√≠, tomamos la currentUserQuery y colocamos los datos resultantes en el Contexto de React, si existen (eliminando los estados de carga y error de antemano). Luego podemos leer desde ese contexto de manera segura en nuestros componentes hijos, por ejemplo, en el componente UserNameDisplay:

[code]
function UserNameDisplay() {
  const data = useCurrentUserContext()
  return <div>User: {data.username}</div>
}

Con eso, hemos convertido nuestra dependencia impl√≠cita (sabemos que los datos se han obtenido m√°s arriba en el √°rbol) en una dependencia expl√≠cita. Siempre que alguien vea UserNameDisplay, sabr√° que necesitan tener los datos proporcionados desde CurrentUserContextProvider. Esto es algo que puedes tener en cuenta al refactorizar. Si cambias d√≥nde se renderiza el Proveedor, tambi√©n sabr√°s que afectar√° a todos los componentes hijos que utilicen ese contexto. Esto es algo que no puedes saber cuando un componente solo utiliza una consulta, porque las consultas suelen ser globales en toda tu aplicaci√≥n, y los datos podr√≠an o no existir.

Agradando a TypeScript
A pesar de todo, TypeScript a√∫n no estar√° muy contento, porque el Contexto de React est√° dise√±ado para funcionar incluso sin un Proveedor, en cuyo caso te proporcionar√° el valor predeterminado del Contexto, que en nuestro caso es nulo. Dado que nunca queremos que useCurrentUserContext funcione en una situaci√≥n en la que estemos fuera de un Proveedor, podemos agregar una invariante a nuestro hook personalizado:

[code]
export const useCurrentUserContext = () => {
  const currentUser = React.useContext(CurrentUserContext)
  if (!currentUser) {
    throw new Error('CurrentUserContext: No value provided')
  }

  return currentUser
}

Este m√©todo asegura que fallaremos de manera r√°pida y con un buen mensaje de error si alguna vez accedemos accidentalmente a useCurrentUserContext en el lugar equivocado. Y con esto, TypeScript inferir√° el valor "User" para nuestro hook personalizado, por lo que podemos usarlo de manera segura y acceder a sus propiedades.

Sincronizaci√≥n de Estado
Podr√≠as estar pensando: ¬øNo es esto una "sincronizaci√≥n de estado" - copiar un valor de React Query y ponerlo en otro m√©todo de distribuci√≥n de estado?

La respuesta es: ¬°No, no lo es! La √∫nica fuente de verdad sigue siendo la consulta (query). No hay forma de cambiar el valor de contexto aparte del Proveedor (Provider), que siempre reflejar√° los datos m√°s recientes que tiene la consulta. Nada se copia aqu√≠ y nada puede desincronizarse. Pasar datos desde React Query como una propiedad (prop) a un componente hijo tampoco es una "sincronizaci√≥n de estado", y dado que el contexto es similar a la transmisi√≥n de propiedades (prop drilling), tampoco es una "sincronizaci√≥n de estado".

Cascadas de Solicitudes
Nada est√° exento de desventajas, y esta t√©cnica tampoco lo est√°. Espec√≠ficamente, podr√≠a crear cascadas de solicitudes en la red, ya que el √°rbol de componentes se detendr√° en su renderizaci√≥n (se "suspende") en el Proveedor (Provider), por lo que los componentes secundarios no se renderizar√°n y no podr√°n realizar solicitudes a la red, incluso si no est√°n relacionados.

Principalmente considerar√≠a este enfoque para los datos que son obligatorios para mi sub-√°rbol: la informaci√≥n del usuario es un buen ejemplo, ya que de todos modos podr√≠amos no saber qu√© renderizar sin esos datos.

Suspense
Hablando sobre Suspense: S√≠, puedes lograr una arquitectura similar con React Suspense, y s√≠, tiene la misma desventaja: posibles cascadas de solicitudes, de las cuales ya he hablado en el punto #17: Alimentando la Cach√© de Consultas (Query Cache).

Un problema es que en la versi√≥n principal actual (v4), usar "suspense: true" en tu consulta (query) no estrechar√° el tipo de datos, porque todav√≠a hay formas de desactivar la consulta y evitar que se ejecute.

Sin embargo, en la versi√≥n v5, habr√° un gancho expl√≠cito llamado "useSuspenseQuery", donde los datos est√°n garantizados para estar definidos una vez que el componente se renderiza. Con eso, podemos hacer:

[code]
function UserNameDisplay() {
  const { data } = useSuspenseQuery(...)
  return <div>User: {data.username}</div>
}

y TypeScript estar√° contento al respecto. üéâ